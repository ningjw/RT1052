#include "main.h"

#define DEVICE_BLE_NAME "BLE Communication"
#define SET_COMMOND_MODE()       GPIO_PinWrite(BOARD_BTM_MODE_GPIO, BOARD_BTM_MODE_PIN, 1);
#define SET_THROUGHPUT_MODE()    GPIO_PinWrite(BOARD_BTM_MODE_GPIO, BOARD_BTM_MODE_PIN, 0);
#define BLE_POWER_ON()           GPIO_PinWrite(BOARD_PWR_WIFI_BLE_GPIO, BOARD_PWR_WIFI_BLE_PIN, 1);
#define BLE_RESET()              GPIO_PinWrite(BOARD_PWR_WIFI_BLE_GPIO, BOARD_PWR_WIFI_BLE_PIN, 0);

#define EVT_OK       (1 << 0)//接受到数据事件


#define LPUART2_BUFF_LEN   160
AT_NONCACHEABLE_SECTION_INIT(uint8_t g_lpuart2RxBuf[LPUART2_BUFF_LEN]) = {0};            //串口接收缓冲区
AT_NONCACHEABLE_SECTION_INIT(char    g_lpuart2TxBuf[LPUART2_BUFF_LEN]) = {0};            //串口发送缓冲区
lpuart_transfer_t   receiveXfer;
lpuart_transfer_t   sendXfer;
TaskHandle_t        BLE_TaskHandle = NULL;//蓝牙任务句柄
SendMsgFunc_t       SendMsgCallback;
EventGroupHandle_t  RecvAckEvt = NULL;//串口收到AT指令回令的信号量，可在串口接收空闲后发出

ATCfg_t g_at_cfg = {
    .resp_time = 2000,
    .try_times = 2,
    .try_cnt = 0,
};

volatile bool rxBufferEmpty;
volatile bool txBufferFull;
volatile bool txOnGoing;
volatile bool rxOnGoing;

/* LPUART 回调函数 */
void LPUART2_Callback(LPUART_Type *base, lpuart_edma_handle_t *handle, status_t status, void *userData)
{
    userData = userData;

    if (kStatus_LPUART_TxIdle == status)
    {
        txBufferFull = false;
        txOnGoing = false;
    }

    if (kStatus_LPUART_RxIdle == status)
    {
        rxBufferEmpty = false;
        rxOnGoing = false;
    }
}



/***************************************************************************************
  * @brief   发送一个字符串 
  * @input   base:选择端口; data:将要发送的数据
  * @return  
***************************************************************************************/
void LPUART2_SendString(const char *str)
{
    LPUART_WriteBlocking(LPUART2, (uint8_t *)str, strlen(str));
}





/*****************************************************************
* 功能：发送AT指令
* 输入: send_buf:发送的字符串
		recv_str：期待回令中包含的子字符串
        p_at_cfg：AT配置
* 输出：执行结果代码
******************************************************************/
uint8_t AT_SendCmd(const char *cmd, const char *param, const char *recv_str, ATCfg_t *p_at_cfg)
{
    p_at_cfg->try_cnt = 0;
    EventBits_t at_event;
    
    memset(g_lpuart2TxBuf, sizeof(g_lpuart2TxBuf), 0);
    strcpy(g_lpuart2TxBuf, "AT");
    strcat(g_lpuart2TxBuf, cmd);
    if (NULL != param){
        strcat(g_lpuart2TxBuf, "=");
        strcat(g_lpuart2TxBuf, param);
    }
    strcat(g_lpuart2TxBuf, "\r\n");
    
retry:
    LPUART2_SendString(g_lpuart2TxBuf);//发送AT指令
    
    if (NULL == recv_str ) {
        return true;
    }
    
    /*  等待接收事件标志, */
    at_event = xEventGroupWaitBits(RecvAckEvt,  /*  事件对象句柄 */
                                EVT_OK,      /*  接收 任务 感兴趣的事件 */
                                pdFALSE,     /*  退出不清除事件位 */
                                pdFALSE,     /*  逻辑或等待事件 */
                                p_at_cfg->resp_time);/*  指定超时时间*/
    
    if( (at_event & EVT_OK) == EVT_OK ){
        xEventGroupClearBits(RecvAckEvt, EVT_OK);//清除事件
        //接收到的数据中包含响应的数据
        if(strstr((char *)g_lpuart2RxBuf, recv_str) != NULL){
            return true;
        }else {
            if(p_at_cfg->try_cnt++ > p_at_cfg->try_times){
                return false;
            }
            goto retry;//重试
        }
        
    }else{//回复超时
        if(p_at_cfg->try_cnt++ > p_at_cfg->try_times){
            return false;
        }
        goto retry;
    }
}

/*****************************************************************
* 功能：发送数组数据
* 输入: send_buf:发送的数组
		buf_len：数组长度
		recv_str：期待回令中包含的子字符串
        p_at_cfg：AT配置
* 输出：执行结果代码
******************************************************************/
uint8_t AT_SendData(const char *send_buf, uint8_t buf_len, const char *recv_str, ATCfg_t *p_at_cfg)
{
    memset(g_lpuart2TxBuf, sizeof(g_lpuart2TxBuf), 0);
    
    sprintf(g_lpuart2TxBuf, "AT+LESEND=%d,", buf_len);
    
    strcat(g_lpuart2TxBuf,send_buf);
    
    LPUART2_SendString(g_lpuart2TxBuf);//发送数据
    
    return 0;
}


char set_rtc[] = "{\"Id\":1,\"Sid\":0,\"Y\":2019,\"Mon\":12,\"D\":16,\"H\":9,\"Min\":0,\"S\":0}";
char get_rtc[] = "{\"Id\":2,\"Sid\":0}";
/***********************************************************************
  * @ 函数名  ： BLE_AppTask
  * @ 功能说明： 为了方便管理，所有的任务创建函数都放在这个函数里面
  * @ 参数    ： 无
  * @ 返回值  ： 无
  **********************************************************************/
void BLE_AppTask(void)
{
    uint8_t ret = false;
    
//    ParseProtocol(get_rtc);
    receiveXfer.data     = g_lpuart2RxBuf;
    receiveXfer.dataSize = LPUART2_BUFF_LEN;
    
    /* 设置UART发送和接收传输结构体 */
    sendXfer.data = (uint8_t *)g_lpuart2TxBuf;
    sendXfer.dataSize = LPUART2_BUFF_LEN;

    /*  创建 事件组 */
    RecvAckEvt = xEventGroupCreate();
    
    PRINTF("BLE Task Create and Running\r\n");
    
    ret = AT_SendCmd(BT_NAME, DEVICE_BLE_NAME, RESP_OK, &g_at_cfg);//设置蓝牙名称
    if( ret == true ){//显示蓝牙错误状态指示等.
        g_sys_para2.bleLedStatus = BLE_READY;
        SET_THROUGHPUT_MODE();
    }
    while(1)
    {
            /* 如果接收空闲并且接收缓冲区为空，表示当前串口空闲此时等待接收数据*/
    if ((!rxOnGoing) && rxBufferEmpty)
    {
      rxOnGoing = true;
      LPUART_ReceiveEDMA(LPUART2, &LPUART2_LPUART_eDMA_Handle, &receiveXfer);
    }
    
    /* 如果发送空闲并且发送缓冲器满，此时应当开始发送数据*/
    if ((!txOnGoing) && txBufferFull)
    {
      txOnGoing = true;
      LPUART_SendEDMA(LPUART2, &LPUART2_LPUART_eDMA_Handle, &sendXfer);
    }
    
    /* 如果发送缓冲区空并且接收缓冲区满，此时应将接收缓冲区的内容拷贝到发送缓冲区 */
    if ((!rxBufferEmpty) && (!txBufferFull))
    {
      memcpy(g_lpuart2TxBuf, g_lpuart2RxBuf, LPUART2_BUFF_LEN);
      rxBufferEmpty = true;
      txBufferFull = true;
    }
    
        /*  等待接收事件标志 */
//        xEventGroupWaitBits(RecvAckEvt, EVT_OK, pdTRUE,pdTRUE, portMAX_DELAY);
        
//        LPUART2_SendString((char *)receiveXfer.data);
    }
}

/***************************************************************************************
  * @brief
  * @input
  * @return
***************************************************************************************/
void LPUART2_IRQHandler(void)
{
//    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
//   /*	接收到数据满了触发中断	*/
//    if ((kLPUART_IdleLineFlag) & LPUART_GetStatusFlags(LPUART2))
//    {
//		/*清除空闲中断*/
//		LPUART2->STAT |= LPUART_STAT_IDLE_MASK; 
//        
//		/*接收eDMA的数据量*/
//		LPUART_TransferGetReceiveCountEDMA(LPUART2, &LPUART2_eDMA_Handle, &receiveXfer.dataSize); 
//		LPUART_TransferAbortReceiveEDMA(LPUART2, &LPUART2_eDMA_Handle);   //eDMA终止接收数据
//		LPUART_ReceiveEDMA(LPUART2, &LPUART2_eDMA_Handle, &receiveXfer);  //使用eDMA接收
//        g_sys_para2.inactiveCount = 0;//接受到蓝牙数据，计数器清空
//        xEventGroupSetBitsFromISR(RecvAckEvt, EVT_OK, &xHigherPriorityTaskWoken); /*设置事件 */
//    }
//    __DSB();
}


